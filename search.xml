<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实现 hash</title>
    <url>/2022/04/08/go_lhash/</url>
    <content><![CDATA[<h3 id="打造一个自己hash-方法"><a href="#打造一个自己hash-方法" class="headerlink" title="打造一个自己hash 方法"></a>打造一个自己hash 方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package bash</span><br><span class="line">// 业务需求紧张</span><br><span class="line">// map[interface&#123;&#125;]int64 中的 int64 后面需要调整未interface</span><br><span class="line">type LHash map[interface&#123;&#125;]int64</span><br><span class="line"></span><br><span class="line">func NewLHash() LHash &#123;</span><br><span class="line">    return make(LHash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Add 加法</span><br><span class="line">func (l LHash) Add(k interface&#123;&#125;, v int64) &#123;</span><br><span class="line">    l[k] += v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Sub 减法</span><br><span class="line">func (l LHash) Sub(k interface&#123;&#125;, v int64) &#123;</span><br><span class="line">    l[k] -= v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Save 保存变更</span><br><span class="line">func (l LHash) Save(k interface&#123;&#125;, v int64) &#123;</span><br><span class="line">    l[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Multi 乘法</span><br><span class="line">func (l LHash) Multi(k interface&#123;&#125;, v int64) &#123;</span><br><span class="line">    if _, ok := l[k]; !ok &#123;</span><br><span class="line">        l[k] = v</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    l[k] = l[k] * v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Division 除法</span><br><span class="line">func (l LHash) Division(k interface&#123;&#125;, v int64) &#123;</span><br><span class="line">    if _, ok := l[k]; !ok &#123;</span><br><span class="line">        l[k] = v</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l[k] = l[k] / v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获得</span><br><span class="line">func (l LHash) GetVal(k interface&#123;&#125;) (ok bool, v int64) &#123;</span><br><span class="line">    v, ok = l[k]</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IsExist 是否存在</span><br><span class="line">func (l LHash) IsExist(k interface&#123;&#125;) (isExist bool) &#123;</span><br><span class="line">    _, isExist = l[k]</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NotExistAndSave 不存在插入, 存在不更新 返回是否存在</span><br><span class="line">func (l LHash) NotExistAndSave(k interface&#123;&#125;, v int64) (isExist bool) &#123;</span><br><span class="line">    if _, ok := l[k]; !ok &#123;</span><br><span class="line">        l[k] = v</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go 姿势</title>
    <url>/2022/04/11/go_lhash%20copy/</url>
    <content><![CDATA[<h3 id="学习一些go-小姿势"><a href="#学习一些go-小姿势" class="headerlink" title="学习一些go 小姿势"></a>学习一些go 小姿势</h3><h4 id="chan-跟-goroutine"><a href="#chan-跟-goroutine" class="headerlink" title="chan 跟 goroutine"></a>chan 跟 goroutine</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">func main()&#123;</span><br><span class="line">    var thisIsChan chan struct&#123;&#125;</span><br><span class="line">    thisIsChan = make(chan struct&#123;&#125;)</span><br><span class="line">    // thisIsChan = make(chan struct&#123;&#125;, 10)</span><br><span class="line">    &lt;-thisIsChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>以上代码中， build 正常通过， 运行就会出现painc(&quot;fatal error: all goroutines are asleep - deadlock!&quot;)
处理：只要有一条 goroutine running 代码都可以正常运行 
</code></pre>
<h4 id="slice-地址问题"><a href="#slice-地址问题" class="headerlink" title="slice 地址问题"></a>slice 地址问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">  func main()&#123;</span><br><span class="line">      a := []int16&#123;1, 2, 3&#125;</span><br><span class="line">      b := a[1:]</span><br><span class="line">      b[0] = 4</span><br><span class="line">      // 4 , 4</span><br><span class="line">      // a b 地址相同</span><br><span class="line">      fmt.Println(a[1], b[0])</span><br><span class="line">      </span><br><span class="line">      a = append(a, 6)</span><br><span class="line">      b[0] = 5</span><br><span class="line">      // 4 5</span><br><span class="line">      // 这是a append 地址发生变化</span><br><span class="line">      fmt.Println(a[1], b[0])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
